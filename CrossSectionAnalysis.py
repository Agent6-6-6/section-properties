"""
The CrossSectionAnalysis module contains the CrossSectionAnalysis class, which
provides the methods for analysis and post-processing.
"""

import numpy as np
import scipy.sparse as sp
from scipy.sparse import linalg
import matplotlib.pyplot as plt
import matplotlib.cm as cm

from ElementDefinitions import Tri6
from femUtilities import solveCGS
from femUtilities import solveCGSLagrange
import otherUtilities


class CrossSectionAnalysis:
    """
    Contains elements within the triangular mesh and computes and
    stores section properties.
    """

    def __init__(self, mesh, materials, settings):
        """
        Constructor method takes the mesh object generated by meshpy (mesh),
        the region material properties list and the program settings.
        """

        # save nodes to array
        self.nodes = np.array(mesh.points, dtype=np.dtype(float))
        # save elements to array
        self.elements = np.array(mesh.elements, dtype=np.dtype(int))
        # save attributes to array
        self.attributes = np.array(
            mesh.element_attributes, dtype=np.dtype(int))
        # save total number of nodes in mesh
        self.noNodes = len(self.nodes)

        # swap mid-node order to retain node ordering consistency
        self.elements[:, [3, 4, 5]] = self.elements[:, [5, 3, 4]]

        self.triElements = []  # initialise list holding all element objects

        # build the mesh one element at a time
        for (i, tri) in enumerate(self.elements):
            x1 = self.nodes[tri[0]][0]
            y1 = self.nodes[tri[0]][1]
            x2 = self.nodes[tri[1]][0]
            y2 = self.nodes[tri[1]][1]
            x3 = self.nodes[tri[2]][0]
            y3 = self.nodes[tri[2]][1]
            x4 = self.nodes[tri[3]][0]
            y4 = self.nodes[tri[3]][1]
            x5 = self.nodes[tri[4]][0]
            y5 = self.nodes[tri[4]][1]
            x6 = self.nodes[tri[5]][0]
            y6 = self.nodes[tri[5]][1]

            # populate the vertices
            verts = np.array([[x1, x2, x3, x4, x5, x6],
                              [y1, y2, y3, y4, y5, y6]])

            # extract the element attribute
            att = self.attributes[i]

            # add a tri6 triangular element to the mesh
            self.triElements.append(Tri6(verts, tri, materials[att]))

            # save settings
            self.settings = settings

            self.nu = materials[0]["nu"]  # TODO: calculate weighted(?) nu

    def shiftToCentroid(self, points, holes, controlPoints):
        """
        This method determines the area properties of the mesh and shifts all
        nodes such that the origin coincides with the centroid. This method
        also returns the shifted points, holes and controlPoints.
        """
        # initialise variables
        self.area = 0
        self.qx = 0
        self.qy = 0
        self.ixx_g = 0
        self.iyy_g = 0
        self.ixy_g = 0

        # loop through all the elements in the mesh
        for el in self.triElements:
            # calculate properties for each element
            (elArea, elQx, elQy, elIxx_g, elIyy_g,
             elIxy_g) = el.geometricProperties()

            # add element properties to global sum
            self.area += elArea
            self.qx += elQx
            self.qy += elQy
            self.ixx_g += elIxx_g
            self.iyy_g += elIyy_g
            self.ixy_g += elIxy_g

        # calculate centroids
        self.cx = self.qy / self.area
        self.cy = self.qx / self.area

        # shift all nodes such that the origin coincides with the centroid:
        # loop through all the nodes in the mesh
        for node in self.nodes:
            node[0] -= self.cx
            node[1] -= self.cy

        # loop through all elements in the mesh
        for el in self.triElements:
            el.xy[0, :] -= self.cx
            el.xy[1, :] -= self.cy

        # loop through all the points in the mesh
        for pt in points:
            pt[0] -= self.cx
            pt[1] -= self.cy

        # loop through all the holes in the mesh
        for h in holes:
            h[0] -= self.cx
            h[1] -= self.cy

        # loop through all the controlPoints in the mesh
        for cp in controlPoints:
            cp[0] -= self.cx
            cp[1] -= self.cy

        return (points, holes, controlPoints)

    def computeSectionProperties(self, points, facets, holes, controlPoints,
                                 materials):
        """
        This function computes the the cross section properties for the mesh.
        """

        # ----------------------------------------------------------------------
        # GEOMETRIC SECTION PROPERTIES:
        # ----------------------------------------------------------------------
        # calculate second moments of area about the centroidal xy axis
        self.ixx_c = self.ixx_g - self.qx ** 2 / self.area
        self.iyy_c = self.iyy_g - self.qy ** 2 / self.area
        self.ixy_c = self.ixy_g - self.qx * self.qy / self.area

        # calculate section modulii about the centroidal xy axis
        self.centroidalSectionModulii()

        # calculate radii of gyration about centroidal xy axis
        self.rx_c = (self.ixx_c / self.area) ** 0.5
        self.ry_c = (self.iyy_c / self.area) ** 0.5

        # calculate prinicpal 2nd moments of area about the centroidal xy axis
        Delta = (((self.ixx_c - self.iyy_c) / 2) ** 2 + self.ixy_c ** 2) ** 0.5
        self.i11_c = (self.ixx_c + self.iyy_c) / 2 + Delta
        self.i22_c = (self.ixx_c + self.iyy_c) / 2 - Delta

        # calculate initial principal axis angle
        tol = 1e-12  # tolerance to avoid round off error when ixy << 1
        if abs(self.ixx_c - self.i11_c) < tol * self.i11_c:
            self.phi = 0
        else:
            self.phi = np.arctan2(
                self.ixx_c - self.i11_c, self.ixy_c) * 180 / np.pi

        # calculate section modulii about the principal axis
        self.principalSectionModulii()

        # calculate radii of gyration about centroidal principal axis
        self.r1_c = (self.i11_c / self.area) ** 0.5
        self.r2_c = (self.i22_c / self.area) ** 0.5

        # ----------------------------------------------------------------------
        # WARPING SECTION PROPERTIES:
        # ----------------------------------------------------------------------
        # initialise text variable
        processText = ""

        # assemble stiffness matrix and load vector for warping function
        if (self.settings.outputLog):
            processText = ("-- Assembling stiffness matrix " +
                           "and torsion load vector...")
        (shearK, shearKLG, torsionF) = otherUtilities.functionTimer(
            processText, self.assembleTorsionMatrices)

        # ILU decomposition on regular stiffness matrix
        preCond = linalg.LinearOperator(
            (self.noNodes, self.noNodes), linalg.spilu(shearK).solve)

        # ILU decomposition on Lagrangian stiffness matrix
        preCondLG = linalg.LinearOperator(
            (self.noNodes + 1, self.noNodes + 1), linalg.spilu(shearKLG).solve)

        # solve for warping constant
        if (self.settings.outputLog):
            processText = "-- Solving for warping constant..."
        self.omega = otherUtilities.functionTimer(
            processText, solveCGS, shearK, torsionF, self.settings.tol,
            preCond)

        # determine the torsion constant
        self.J = self.ixx_c + self.iyy_c - self.omega.dot(
            shearK.dot(np.transpose(self.omega)))

        # assemble shear force vectors, shear centre integrals and warping
        # moment integrals
        if (self.settings.outputLog):
            processText = '-- Assembling shear vectors and integrals...'
        ((shearFPsi, shearFPhi, shearCentreXInt, shearCentreYInt, Q_omega,
            i_omega, i_xomega, i_yomega)) = (otherUtilities.functionTimer(
                processText, self.assembleShearVectors, self.ixx_c, self.iyy_c,
                self.ixy_c))

        # solve for shear functions
        if (self.settings.outputLog):
            processText = "-- Solving for shear function Psi..."
        self.Psi = otherUtilities.functionTimer(
            processText, solveCGSLagrange, shearKLG, shearFPsi,
            self.settings.tol, preCondLG)

        if (self.settings.outputLog):
            processText = "-- Solving for shear function Phi..."
        self.Phi = otherUtilities.functionTimer(
            processText, solveCGSLagrange, shearKLG, shearFPhi,
            self.settings.tol, preCondLG)

        # calculate shear centres (elasticity approach)
        self.Delta_s = 2 * (1 + self.nu) * (
            self.ixx_c * self.iyy_c - self.ixy_c ** 2)
        self.x_se = (1 / self.Delta_s) * (
            (self.nu / 2 * shearCentreXInt) - torsionF.dot(self.Phi))
        self.y_se = (1 / self.Delta_s) * (
            (self.nu / 2 * shearCentreYInt) + torsionF.dot(self.Psi))
        (self.x1_se, self.y2_se) = otherUtilities.principalCoordinate(
            self.phi, self.x_se, self.y_se)

        # calculate shear centres (Trefftz's approach)
        self.x_st = (self.ixy_c * i_xomega - self.iyy_c * i_yomega) / (
            self.ixx_c * self.iyy_c - self.ixy_c ** 2)
        self.y_st = (self.ixx_c * i_xomega - self.ixy_c * i_yomega) / (
            self.ixx_c * self.iyy_c - self.ixy_c ** 2)

        # calculate shear deformation coefficients
        if (self.settings.outputLog):
            processText = '-- Assembling shear deformation coefficients...'
        (kappa_x, kappa_y, kappa_xy) = otherUtilities.functionTimer(
            processText, self.assembleShearCoefficients, self.ixx_c,
            self.iyy_c, self.ixy_c)

        # calculate shear areas wrt global axis
        self.A_sx = self.Delta_s ** 2 / kappa_x
        self.A_sy = self.Delta_s ** 2 / kappa_y
        self.A_sxy = self.Delta_s ** 2 / kappa_xy

        # calculate shear areas wrt principal bending axis:
        # calculate the shear coefficients (alpha) forming a 2nd order tensor
        alpha_xx = kappa_x * self.area / self.Delta_s ** 2
        alpha_yy = kappa_y * self.area / self.Delta_s ** 2
        alpha_xy = kappa_xy * self.area / self.Delta_s ** 2

        # rotate the tensor by the principal axis angle
        phi_rad = self.phi * np.pi / 180
        R = (np.array([[np.cos(phi_rad),  np.sin(phi_rad)],
                       [-np.sin(phi_rad), np.cos(phi_rad)]]))

        rotatedAlpha = R.dot(np.array(
            [[alpha_xx, alpha_xy],
             [alpha_xy, alpha_yy]])).dot(np.transpose(R))

        # recalculate the shear area based on the rotated alpha value
        self.A_s11 = self.area / rotatedAlpha[0, 0]
        self.A_s22 = self.area / rotatedAlpha[1, 1]

        # calculate warping constant
        self.Gamma = (i_omega - Q_omega ** 2 / self.area -
                      self.y_se * i_xomega + self.x_se * i_yomega)

        # calculate global plastic properties
        processText = "-- Calculating global plastic properties..."
        otherUtilities.functionTimer(
            processText, self.computeGlobalPlasticProperties, points, facets,
            holes, controlPoints, materials)

        # calculate principal plastic properties
        processText = "-- Calculating principal plastic properties..."
        otherUtilities.functionTimer(
            processText, self.computePrincipalPlasticProperties, points,
            facets, holes, controlPoints, materials)

        # calculate section stresses
        processText = "-- Calculating cross-section stresses..."
        otherUtilities.functionTimer(
            processText, self.calculateStress)

    # --------------------------------------------------------------------------
    # SECTION PROPERTY METHODS:
    # --------------------------------------------------------------------------

    def centroidalSectionModulii(self):
        """
        This method calculates the elastic section modulii about the
        centroidal axis.
        """

        # determine extreme values of the section in cartesian co-ordinates
        self.xmax = self.nodes[:, 0].max()
        self.xmin = self.nodes[:, 0].min()
        self.ymax = self.nodes[:, 1].max()
        self.ymin = self.nodes[:, 1].min()

        # evaluate section modulii
        self.zxx_plus = self.ixx_c / abs(self.ymax)
        self.zxx_minus = self.ixx_c / abs(self.ymin)
        self.zyy_plus = self.iyy_c / abs(self.xmax)
        self.zyy_minus = self.iyy_c / abs(self.xmin)

    def principalSectionModulii(self):
        """
        This method calculates the elastic section modulii about the
        principal axis.
        """

        # first, calculate the extreme values with respect to the
        # principal axes:
        # loop through all points in the mesh
        for (i, pt) in enumerate(self.nodes):
            # determine the coordinate of the point wrt the principal axis
            (x1, y2) = otherUtilities.principalCoordinate(
                self.phi, pt[0], pt[1])

            # initialise min, max variables
            if i == 0:
                self.x1max = x1
                self.x1min = x1
                self.y2max = y2
                self.y2min = y2

            # update the mins and maxs where necessary
            self.x1max = max(self.x1max, x1)
            self.x1min = min(self.x1min, x1)
            self.y2max = max(self.y2max, y2)
            self.y2min = min(self.y2min, y2)

        # evaluate principal section modulii
        self.z11_plus = self.i11_c / abs(self.y2max)
        self.z11_minus = self.i11_c / abs(self.y2min)
        self.z22_plus = self.i22_c / abs(self.x1max)
        self.z22_minus = self.i22_c / abs(self.x1min)

    def computeGlobalPlasticProperties(self, points, facets, holes,
                                       controlPoints, materials):
        """
        This method computes the plastic centroid and plastic section modulii
        for global axis bending.
        """

        # unit vectors in the x & y directions
        ux = [1, 0]
        uy = [0, 1]

        # compute plastic centroids and plastic section modulii:
        # compute x-location of plastic centroid
        (self.x_pc, topA, botA, topCenX, botCenX) = otherUtilities.pcAlgorithm(
            self.settings.tol, 1000, uy, self.xmin, self.xmax,
            points, facets, holes, controlPoints, self.nodes, self.elements,
            materials, 1)

        # compute y-location of the plastic centroid
        (self.y_pc, topA, botA, topCenY, botCenY) = otherUtilities.pcAlgorithm(
            self.settings.tol, 1000, ux, self.ymin, self.ymax,
            points, facets, holes, controlPoints, self.nodes, self.elements,
            materials, 2)

        self.Sxx = self.area / 2 * abs(topCenY[1] - botCenY[1])
        self.Syy = self.area / 2 * abs(topCenX[0] - botCenX[0])

        # compute shape factors
        self.SF_xx_plus = self.Sxx / self.zxx_plus
        self.SF_xx_minus = self.Sxx / self.zxx_minus
        self.SF_yy_plus = self.Syy / self.zyy_plus
        self.SF_yy_minus = self.Syy / self.zyy_minus

    def computePrincipalPlasticProperties(self, points, facets, holes,
                                          controlPoints, materials):
        """
        This method computes the plastic centroid and plastic section modulii
        for principal axis bending.
        """

        # unit vectors in the 1 & 2 directions
        u1 = np.array(
            [np.cos(self.phi * np.pi / 180), np.sin(self.phi * np.pi / 180)])
        u2 = np.array(
            [-np.sin(self.phi * np.pi / 180), np.cos(self.phi * np.pi / 180)])

        # compute plastic centroids and plastic section modulii
        (x1_pc, topA, botA, topCen1, botCen1) = otherUtilities.pcAlgorithm(
            self.settings.tol, 1000, -u1, self.y2min, self.y2max,
            points, facets, holes, controlPoints, self.nodes, self.elements,
            materials, 1)
        (y2_pc, topA, botA, topCen2, botCen2) = otherUtilities.pcAlgorithm(
            self.settings.tol, 1000, -u2, self.x1min, self.x1max,
            points, facets, holes, controlPoints, self.nodes, self.elements,
            materials, 2)

        # calculate the area centroids in the principal coordinate system
        (tc1_1, tc1_2) = otherUtilities.principalCoordinate(
            self.phi, topCen1[0], topCen1[1])
        (bc1_1, bc1_2) = otherUtilities.principalCoordinate(
            self.phi, botCen1[0], botCen1[1])
        (tc2_1, tc2_2) = otherUtilities.principalCoordinate(
            self.phi, topCen2[0], topCen2[1])
        (bc2_1, bc2_2) = otherUtilities.principalCoordinate(
            self.phi, botCen2[0], botCen2[1])

        self.x1_pc = x1_pc * u2[0] + y2_pc * u1[0]
        self.y2_pc = x1_pc * u2[1] + y2_pc * u1[1]
        self.S11 = self.area / 2 * abs(tc1_2 - bc1_2)
        self.S22 = self.area / 2 * abs(tc2_1 - bc2_1)

        # compute shape factors
        self.SF_11_plus = self.S11 / self.z11_plus
        self.SF_11_minus = self.S11 / self.z11_minus
        self.SF_22_plus = self.S22 / self.z22_plus
        self.SF_22_minus = self.S22 / self.z22_minus

    def assembleTorsionMatrices(self):
        """
        This method assembles the stiffness matrix to be used for warping
        problems, and also the torsion load vector. The stiffness matrix is
        assembled using the sparse COO format.
        """

        # initialise variables
        N = self.noNodes  # size of matrix
        row = []  # list holding row indices
        col = []  # list holding column indices
        data = []  # list holding stiffness matrix entries
        torsionF = np.zeros(N)  # force vector array

        # loop through all elements in the mesh
        for el in self.triElements:
            # determine number of nodes in the current element
            n = len(el.nodes)

            # calculate the element stiffness matrix and torsion load vector
            (elK, elF) = el.torsionProperties()

            # assemble the torsion load vector
            torsionF[el.nodes] += elF

            # create row index vector
            r = np.repeat(el.nodes, n)

            # create column index vector
            c = np.tile(el.nodes, n)

            # flatten element stiffness matrix
            k = elK.flatten()

            # add to global arrays
            row = np.hstack((row, r))
            col = np.hstack((col, c))
            data = np.hstack((data, k))

        shearK = sp.coo_matrix((data, (row, col)), shape=(N, N))

        # construct lagrangian multiplier matrix:
        # column vector of ones
        row = np.hstack((row, range(N)))
        col = np.hstack((col, np.repeat(N, N)))
        data = np.hstack((data, np.repeat(1, N)))

        # row vector of ones
        row = np.hstack((row, np.repeat(N, N)))
        col = np.hstack((col, range(N)))
        data = np.hstack((data, np.repeat(1, N)))

        # zero in bottom right corner
        row = np.hstack((row, N))
        col = np.hstack((col, N))
        data = np.hstack((data, 0))

        shearKLG = sp.coo_matrix((data, (row, col)), shape=(N+1, N+1))

        return (sp.csc_matrix(shearK), sp.csc_matrix(shearKLG), torsionF)

    def assembleShearVectors(self, ixx, iyy, ixy):
        """
        This function assembles load vectors to be used to solve for the shear
        functions, and also calculates integrals to be used in the calculation
        of the shear centre and the warping constant.
        """

        # initialise variables
        shearFPsi = np.zeros(self.noNodes)
        shearFPhi = np.zeros(self.noNodes)
        shearCentreXInt = 0
        shearCentreYInt = 0
        Q_omega = 0
        i_omega = 0
        i_xomega = 0
        i_yomega = 0

        # loop through all elements in the mesh
        for el in self.triElements:
            # calculate the element load vectors and variables
            ((elShearFPsi, elShearFPhi, elShearCentreXInt, elShearCentreYInt,
                elQ_omega, elI_omega, elI_xomega,
                elI_yomega)) = el.shearProperties(
                ixx, iyy, ixy, self.omega[el.nodes])

            # assemble the local results into the global variables
            shearFPsi[el.nodes] += elShearFPsi
            shearFPhi[el.nodes] += elShearFPhi
            shearCentreXInt += elShearCentreXInt
            shearCentreYInt += elShearCentreYInt
            Q_omega += elQ_omega
            i_omega += elI_omega
            i_xomega += elI_xomega
            i_yomega += elI_yomega

        return (shearFPsi, shearFPhi, shearCentreXInt, shearCentreYInt,
                Q_omega, i_omega, i_xomega, i_yomega)

    def assembleShearCoefficients(self, ixx, iyy, ixy):
        """
        This function assembles variables to be used to solve for the shear
        deformation coefficients, which in turn are used to calculate the
        shear areas.
        """

        # initialise variables
        kappa_x = 0
        kappa_y = 0
        kappa_xy = 0

        # loop through all elements in the mesh
        for el in self.triElements:
            # calculate the element variables
            (elKappa_x, elKappa_y, elKappa_xy) = el.shearCoefficients(
                ixx, iyy, ixy, self.Psi[el.nodes], self.Phi[el.nodes])

            # assemble the local results into the global variables
            kappa_x += elKappa_x
            kappa_y += elKappa_y
            kappa_xy += elKappa_xy

        return (kappa_x, kappa_y, kappa_xy)

    def computeAreaSegments(self, u, px, py):
        """
        This method computes the area above and below a line defined by unit
        vector u and point (px,py)
        """

        # allocate area variables
        topA = 0
        botA = 0
        topQx = 0
        topQy = 0
        botQx = 0
        botQy = 0
        topCen = [0, 0]
        botCen = [0, 0]

        # loop through all elements in the mesh
        for el in self.triElements:
            # calculate area of element and its first moments of area
            (elA, Qx, Qy) = el.areaProperties()

            # if the element is not infinitessimally small (meshing artefacts)
            if elA != 0:
                # calculate the element centroid
                elCen = [Qy / elA, Qx / elA]
            else:
                elCen = [0, 0]

            # determine location of element and allocate element areas and
            # first moments of area accordingly
            if (otherUtilities.pointAboveLine(u, px, py, elCen[0], elCen[1])):
                topA += elA
                topQx += Qx
                topQy += Qy
            else:
                botA += elA
                botQx += Qx
                botQy += Qy

        # if the element is not infinitessimally small
        if (topA != 0 and botA != 0):
            # calculate the centroid of the top and bottom areas
            topCen = np.array([topQy / topA, topQx / topA])
            botCen = np.array([botQy / botA, botQx / botA])

        return (topA, botA, topCen, botCen)

    # --------------------------------------------------------------------------
    # STRESS CALCULATION:
    # --------------------------------------------------------------------------

    def calculateStress(self):
        """
        This method calculates the cross-section stresses as a result of unit
        loading (axial, moment, shear, torsion).
        """

        # allocate stress vectors
        self.sigma_zz_axial = np.zeros(self.noNodes)
        self.sigma_zz_bending_xx = np.zeros(self.noNodes)
        self.sigma_zz_bending_yy = np.zeros(self.noNodes)
        self.sigma_zz_bending_11 = np.zeros(self.noNodes)
        self.sigma_zz_bending_22 = np.zeros(self.noNodes)
        self.tau_zx_torsion = np.zeros(self.noNodes)
        self.tau_zy_torsion = np.zeros(self.noNodes)
        self.tau_zx_shear_x = np.zeros(self.noNodes)
        self.tau_zy_shear_x = np.zeros(self.noNodes)
        self.tau_zx_shear_y = np.zeros(self.noNodes)
        self.tau_zy_shear_y = np.zeros(self.noNodes)

        # allocate nodal weights vector for nodal averaging
        nodal_weights = np.zeros(self.noNodes)

        # loop through all elements in the mesh
        for el in self.triElements:
            # evaluate stresses at nodes
            (elSigma_zz_axial, elSigma_zz_bending_xx, elSigma_zz_bending_yy,
                elSigma_zz_bending_11, elSigma_zz_bending_22, elTau_zx_torsion,
                elTau_zy_torsion, elTau_shear_zx_x, elTau_shear_zy_x,
                elTau_shear_zx_y, elTau_shear_zy_y,
                weights) = el.calculateStress(
                self.area, self.ixx_c, self.iyy_c, self.ixy_c, self.i11_c,
                self.i22_c, self.phi, self.omega[el.nodes], self.J,
                self.Psi[el.nodes], self.Phi[el.nodes], self.Delta_s)

            # add stresses to global vectors
            self.sigma_zz_axial[el.nodes] += elSigma_zz_axial[:, 0] * weights
            self.sigma_zz_bending_xx[el.nodes] += (
                elSigma_zz_bending_xx * weights)
            self.sigma_zz_bending_yy[el.nodes] += (
                elSigma_zz_bending_yy * weights)
            self.sigma_zz_bending_11[el.nodes] += (
                elSigma_zz_bending_11 * weights)
            self.sigma_zz_bending_22[el.nodes] += (
                elSigma_zz_bending_22 * weights)
            self.tau_zx_torsion[el.nodes] += elTau_zx_torsion * weights
            self.tau_zy_torsion[el.nodes] += elTau_zy_torsion * weights
            self.tau_zx_shear_x[el.nodes] += elTau_shear_zx_x * weights
            self.tau_zy_shear_x[el.nodes] += elTau_shear_zy_x * weights
            self.tau_zx_shear_y[el.nodes] += elTau_shear_zx_y * weights
            self.tau_zy_shear_y[el.nodes] += elTau_shear_zy_y * weights

            # increment the nodal count vector
            nodal_weights[el.nodes] += weights

        # nodal averaging
        self.sigma_zz_axial *= 1 / nodal_weights
        self.sigma_zz_bending_xx *= 1 / nodal_weights
        self.sigma_zz_bending_yy *= 1 / nodal_weights
        self.sigma_zz_bending_11 *= 1 / nodal_weights
        self.sigma_zz_bending_22 *= 1 / nodal_weights
        self.tau_zx_torsion *= 1 / nodal_weights
        self.tau_zy_torsion *= 1 / nodal_weights
        self.tau_zx_shear_x *= 1 / nodal_weights
        self.tau_zy_shear_x *= 1 / nodal_weights
        self.tau_zx_shear_y *= 1 / nodal_weights
        self.tau_zy_shear_y *= 1 / nodal_weights

    def evaluateSectionStress(self, loadData):
        """
        This method scales the results obtained from the calculateStress
        function by the design actions specified as input.
        """

        # scale unit stresses by design actions
        self.axialStress = self.sigma_zz_axial * loadData.Nzz
        self.bendingStress = (self.sigma_zz_bending_xx * loadData.Mxx +
                              self.sigma_zz_bending_yy * loadData.Myy +
                              self.sigma_zz_bending_11 * loadData.M11 +
                              self.sigma_zz_bending_22 * loadData.M22)
        self.torsionStress_zx = self.tau_zx_torsion * loadData.Mzz
        self.torsionStress_zy = self.tau_zy_torsion * loadData.Mzz
        self.torsionStress = ((self.torsionStress_zx ** 2 +
                               self.torsionStress_zy ** 2) ** 0.5)
        self.shearStress_zx = (self.tau_zx_shear_x * loadData.Vx +
                               self.tau_zx_shear_y * loadData.Vy)
        self.shearStress_zy = (self.tau_zy_shear_x * loadData.Vx +
                               self.tau_zy_shear_y * loadData.Vy)
        self.shearStress = ((self.shearStress_zx ** 2 +
                             self.shearStress_zy ** 2) ** 0.5)

        # compute combined stresses
        self.sigma_zz = self.axialStress + self.bendingStress
        self.tau_zx = self.torsionStress_zx + self.shearStress_zx
        self.tau_zy = self.torsionStress_zy + self.shearStress_zy
        self.tau = (self.tau_zx ** 2 + self.tau_zy ** 2) ** 0.5
        self.vonMises = ((self.sigma_zz ** 2 + 3 * (self.tau ** 2)) ** 0.5)

    # --------------------------------------------------------------------------
    # POST-PROCESSING METHODS:
    # --------------------------------------------------------------------------

    def plotResults(self, plots):
        """
        This method generates all the plots in the 'plots' list.
        """

        for plot in plots:
            # initialise plot variables
            x = []  # x-component of vector
            y = []  # y-component of vector
            z = []  # contour values
            globalAxis = False
            principalAxis = False
            nodes = False
            plotTitle = ""
            centroids = False
            plotType = ""

            if (plot.lower() == "axial"):
                z = self.axialStress
                plotTitle = "Axial Stress"
                plotType = "contour"
            elif (plot.lower() == "bending"):
                z = self.bendingStress
                plotTitle = "Bending Stress"
                plotType = "contour"
            elif (plot.lower() == "torsion"):
                z = self.torsionStress
                plotTitle = "Torsion Stress"
                plotType = "contour"
            elif (plot.lower() == "torsion-vector"):
                x = self.torsionStress_zx
                y = self.torsionStress_zy
                plotTitle = "Torsion Stress Vectors"
                plotType = "vector"
            elif (plot.lower() == "shear"):
                z = self.shearStress
                plotTitle = "Transverse Shear Stress"
                plotType = "contour"
            elif (plot.lower() == "shear-zx"):
                z = self.shearStress_zx
                plotTitle = "Transverse Shear (zx) Stress"
                plotType = "contour"
            elif (plot.lower() == "shear-zy"):
                z = self.shearStress_zy
                plotTitle = "Transverse Shear (zy) Stress"
                plotType = "contour"
            elif (plot.lower() == "shear-vector"):
                x = self.shearStress_zx
                y = self.shearStress_zy
                plotTitle = "Transverse Shear Stress Vectors"
                plotType = "vector"
            elif (plot.lower() == "combined-normal"):
                z = self.sigma_zz
                plotTitle = "Combined Normal Stress"
                plotType = "contour"
            elif (plot.lower() == "combined-shear"):
                z = self.tau
                plotTitle = "Combined Shear Stress"
            elif (plot.lower() == "combined-shear-vector"):
                x = self.tau_zx
                y = self.tau_zy
                plotTitle = "Combined Shear Stress Vectors"
                plotType = "vector"
            elif (plot.lower() == "von-mises"):
                z = self.vonMises
                plotTitle = "von Mises Stress"
                plotType = "contour"
            elif (plot.lower() == "centroids"):
                z = None
                globalAxis = True
                principalAxis = True
                centroids = True
                plotTitle = "Centroids"
                plotType = "contour"
            elif (plot.lower() == "mesh"):
                z = None
                globalAxis = True
                plotTitle = "Mesh"
                plotType = "contour"

            # if we are displaying a contour plot
            if (plotType == "contour"):
                self.contourPlot(
                    globalAxis=globalAxis, principalAxis=principalAxis, z=z,
                    nodes=nodes, plotTitle=plotTitle, centroids=centroids)
            elif (plotType == "vector"):
                self.quiverPlot(u=x, v=y, plotTitle=plotTitle)

    def contourPlot(self, globalAxis=False, principalAxis=False, z=None,
                    nodes=False, plotTitle="", centroids=False):
        """
        This method generates a plot of the mesh with an optional contour
        plot of results (z). Additional options include displaying the nodes, a
        plot title, and the principal axis and centroids.
        """

        fig, ax = plt.subplots()
        ax.set_aspect("equal")  # set the scale on the x and y axes equal

        # plot the title and axis labels
        ax.set_title(plotTitle)
        ax.set_xlabel("x")
        ax.set_ylabel("y")

        # plot the mesh
        ax.triplot(self.nodes[:, 0], self.nodes[:, 1], self.elements[:, 0:3],
                   lw=0.5, color='black')

        # plot the global axis as lines
        if (globalAxis):
            # determine min and max values of the nodes
            (xmin, ymin) = np.amin(self.nodes, axis=0)
            (xmax, ymax) = np.amax(self.nodes, axis=0)
            xLim = xmax - xmin
            yLim = ymax - ymin

            # plot x axis
            ax.plot([xmin - 0.1 * xLim, xmax + 0.1 * xLim],
                    [-self.cy, -self.cy], label="Global x-axis")
            # plot y axis
            ax.plot([-self.cx, -self.cx],
                    [ymin - 0.1 * yLim, ymax + 0.1 * yLim],
                    label="Global y-axis")

        # plot the principal axis as lines
        if principalAxis:
            start_11 = otherUtilities.globalCoordinate(
                self.phi, self.x1min, 0)
            end_11 = otherUtilities.globalCoordinate(
                self.phi, self.x1max, 0)
            start_22 = otherUtilities.globalCoordinate(
                self.phi, 0, self.y2min)
            end_22 = otherUtilities.globalCoordinate(
                self.phi, 0, self.y2max)

            lim11_x = end_11[0] - start_11[0]
            lim11_y = end_11[1] - start_11[1]
            lim22_x = end_22[0] - start_22[0]
            lim22_y = end_22[1] - start_22[1]

            ax.plot([start_11[0] - 0.1 * lim11_x, end_11[0] + 0.1 * lim11_x],
                    [start_11[1] - 0.1 * lim11_y, end_11[1] + 0.1 * lim11_y],
                    label='Principal 11-axis')
            ax.plot([start_22[0] - 0.1 * lim22_x, end_22[0] + 0.1 * lim22_x],
                    [start_22[1] - 0.1 * lim22_y, end_22[1] + 0.1 * lim22_y],
                    label='Principal 22-axis')

        # plot the locations of the various centroids
        if centroids:
            ax.scatter(0, 0, facecolors='None', edgecolors='k', marker='o',
                       s=100, label='Elastic Centroid')
            ax.scatter(self.x_pc, self.y_pc, c='k', marker='x', s=100,
                       label='Global Plastic Centroid')
            ax.scatter(self.x1_pc, self.y2_pc, facecolors='None',
                       edgecolors='k', marker='s', s=100,
                       label='Principal Plastic Centroid')
            ax.scatter(self.x_se, self.y_se, c='k', marker='+', s=100,
                       label='Shear Centre')

        # plot a contour of results defined by z
        if z is not None:
            cmap = cm.get_cmap(name='jet')

            # if values are not all constant
            if np.amax(z) - np.amin(z) > 1e-6:
                v = np.linspace(np.amin(z), np.amax(z), 10, endpoint=True)
            else:
                # ten contours
                v = 10

            trictr = ax.tricontourf(
                self.nodes[:, 0], self.nodes[:, 1], self.elements[:, 0:3],
                z, v, cmap=cmap)
            fig.colorbar(trictr, label='Stress')

        # show the nodes
        if nodes:
            ax.plot(self.nodes[:, 0], self.nodes[:, 1], 'ko', markersize=1)

        # show the legend
        if (globalAxis or principalAxis or centroids):
            ax.legend()

        ax.grid(True)
        fig.show()

        return fig

    def quiverPlot(self, u, v, plotTitle=''):
        """
        This method produces a quiver plot of a vector with components u and
        v, overlaid with the mesh.
        """

        fig, ax = plt.subplots()
        ax.set_aspect("equal")  # set the scale on the x and y axes equal

        # plot the title and axis labels
        ax.set_title(plotTitle)
        ax.set_xlabel("x")
        ax.set_ylabel("y")

        # plot the mesh
        plt.triplot(self.nodes[:, 0], self.nodes[:, 1], self.elements[:, 0:3],
                    lw=0.5, color='black')

        # scale the colour with respect to the magnitude of the vector
        c = np.hypot(u, v)
        cmap = cm.get_cmap(name='jet')

        # generate the quiver plot and apply the colourbar
        if np.amin(c) != np.amax(c):
            # only show the quiver plot if there are results
            quiv = ax.quiver(self.nodes[:, 0], self.nodes[:, 1], u, v, c,
                             cmap=cmap)
            v1 = np.linspace(np.amin(c), np.amax(c), 10, endpoint=True)
            fig.colorbar(quiv, label='Stress', ticks=v1)

        ax.grid(True)
        fig.show()

        return fig

    def printResults(self, fmt):
        '''
        This function prints the results of the geometric cross-sectional
        analaysis to the console.
        '''
        print("\n-----------------------------")
        print("Global xy Axis Properties")
        print("-----------------------------")
        print("Area\t = {:>{fmt}}".format(self.area, fmt=fmt))
        print("Qx\t = {:>{fmt}}".format(self.qx, fmt=fmt))
        print("Qy\t = {:>{fmt}}".format(self.qy, fmt=fmt))
        print("cx\t = {:>{fmt}}".format(self.cx, fmt=fmt))
        print("cy\t = {:>{fmt}}".format(self.cy, fmt=fmt))
        print("Ixx_g\t = {:>{fmt}}".format(self.ixx_g, fmt=fmt))
        print("Iyy_g\t = {:>{fmt}}".format(self.iyy_g, fmt=fmt))
        print("Ixy_g\t = {:>{fmt}}\n".format(self.ixy_g, fmt=fmt))
        print("\n-----------------------------")
        print("Centroidal xy Axis Properties")
        print("-----------------------------")
        print("Ixx_c\t = {:>{fmt}}".format(self.ixx_c, fmt=fmt))
        print("Iyy_c\t = {:>{fmt}}".format(self.iyy_c, fmt=fmt))
        print("Ixy_c\t = {:>{fmt}}".format(self.ixy_c, fmt=fmt))
        print("Zxx+\t = {:>{fmt}}".format(self.zxx_plus, fmt=fmt))
        print("Zxx-\t = {:>{fmt}}".format(self.zxx_minus, fmt=fmt))
        print("Zyy+\t = {:>{fmt}}".format(self.zyy_plus, fmt=fmt))
        print("Zyy-\t = {:>{fmt}}".format(self.zyy_minus, fmt=fmt))
        print("rx_c\t = {:>{fmt}}".format(self.rx_c, fmt=fmt))
        print("ry_c\t = {:>{fmt}}\n".format(self.ry_c, fmt=fmt))
        print("\n-----------------------------")
        print("Principal Axis Properties")
        print("-----------------------------")
        print("phi\t = {:>{fmt}}".format(self.phi, fmt=fmt))
        print("I11_c\t = {:>{fmt}}".format(self.i11_c, fmt=fmt))
        print("I22_c\t = {:>{fmt}}".format(self.i22_c, fmt=fmt))
        print("Z11+\t = {:>{fmt}}".format(self.z11_plus, fmt=fmt))
        print("Z11-\t = {:>{fmt}}".format(self.z11_minus, fmt=fmt))
        print("Z22+\t = {:>{fmt}}".format(self.z22_plus, fmt=fmt))
        print("Z22-\t = {:>{fmt}}".format(self.z22_minus, fmt=fmt))
        print("r1_c\t = {:>{fmt}}".format(self.r1_c, fmt=fmt))
        print("r2_c\t = {:>{fmt}}\n".format(self.r2_c, fmt=fmt))
        print("\n-----------------------------")
        print("Torsional Properties")
        print("-----------------------------")
        print("J\t = {:>{fmt}}".format(self.J, fmt=fmt))
        print("Iw\t = {:>{fmt}}\n".format(self.Gamma, fmt=fmt))
        print("\n-----------------------------")
        print("Shear Properties")
        print("-----------------------------")
        print("x_s,e\t = {:>{fmt}}".format(self.x_se, fmt=fmt))
        print("y_s,e\t = {:>{fmt}}".format(self.y_se, fmt=fmt))
        print("x_s,t\t = {:>{fmt}}".format(self.x_st, fmt=fmt))
        print("y_s,t\t = {:>{fmt}}".format(self.y_st, fmt=fmt))
        print("x1_s,e\t = {:>{fmt}}".format(self.x1_se, fmt=fmt))
        print("y2_s,e\t = {:>{fmt}}".format(self.y2_se, fmt=fmt))
        print("A_s,x\t = {:>{fmt}}".format(self.A_sx, fmt=fmt))
        print("A_s,y\t = {:>{fmt}}".format(self.A_sy, fmt=fmt))
        print("A_s,11\t = {:>{fmt}}".format(self.A_s11, fmt=fmt))
        print("A_s,22\t = {:>{fmt}}\n".format(self.A_s22, fmt=fmt))
        print("\n-----------------------------")
        print("Plastic Properties")
        print("-----------------------------")
        print("x_pc = {:>{fmt}}".format(self.x_pc, fmt=fmt))
        print("y_pc = {:>{fmt}}".format(self.y_pc, fmt=fmt))
        print("Sxx = {:>{fmt}}".format(self.Sxx, fmt=fmt))
        print("Syy = {:>{fmt}}".format(self.Syy, fmt=fmt))
        print("SF_xx+ = {:>{fmt}}".format(self.SF_xx_plus, fmt=fmt))
        print("SF_xx- = {:>{fmt}}".format(self.SF_xx_minus, fmt=fmt))
        print("SF_yy+ = {:>{fmt}}".format(self.SF_yy_plus, fmt=fmt))
        print("SF_yy- = {:>{fmt}}".format(self.SF_yy_minus, fmt=fmt))
        print("x1_pc = {:>{fmt}}".format(self.x1_pc, fmt=fmt))
        print("y2_pc = {:>{fmt}}".format(self.y2_pc, fmt=fmt))
        print("S11 = {:>{fmt}}".format(self.S11, fmt=fmt))
        print("S22 = {:>{fmt}}".format(self.S22, fmt=fmt))
        print("SF_11+ = {:>{fmt}}".format(self.SF_11_plus, fmt=fmt))
        print("SF_11- = {:>{fmt}}".format(self.SF_11_minus, fmt=fmt))
        print("SF_22+ = {:>{fmt}}".format(self.SF_22_plus, fmt=fmt))
        print("SF_22- = {:>{fmt}}\n".format(self.SF_22_minus, fmt=fmt))

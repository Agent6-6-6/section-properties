

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sectionproperties.pre.sections &mdash; sectionproperties 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> sectionproperties
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/cross_section.html">cross_section</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/sections.html">Sections</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sectionproperties</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>sectionproperties.pre.sections</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sectionproperties.pre.sections</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sectionproperties.pre.pre</span> <span class="k">as</span> <span class="nn">pre</span>
<span class="kn">import</span> <span class="nn">sectionproperties.post.post</span> <span class="k">as</span> <span class="nn">post</span>


<div class="viewcode-block" id="SectionInput"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.SectionInput">[docs]</a><span class="k">class</span> <span class="nc">SectionInput</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parent class for a cross-section input.</span>

<span class="sd">    Provides an interface for the user to generate common section types as well</span>
<span class="sd">    as section combinations. A method is provided for generating a triangular</span>
<span class="sd">    mesh, for translating the cross-section by (x, y) and for plotting the</span>
<span class="sd">    geometry.</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the SectionInput class.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span> <span class="o">=</span> <span class="n">control_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SectionInput.create_mesh"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.SectionInput.create_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_sizes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a quadratic triangular mesh from the SectionInput object.</span>

<span class="sd">        :param mesh_sizes: A list of maximum element areas corresponding to</span>
<span class="sd">            each region within the cross-section geometry.</span>
<span class="sd">        :type mesh_size: list[float]</span>

<span class="sd">        :return: Object containing generated mesh data</span>
<span class="sd">        :rtype: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: check that size of mesh_sizes matches self.control_points</span>

        <span class="k">return</span> <span class="n">pre</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">,</span> <span class="n">mesh_sizes</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">shift_section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shifts the cross-section parameters by the vector *shift*.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
            <span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="SectionInput.plot_geometry"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.SectionInput.plot_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">plot_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the geometry defined by the input section. If no axes object</span>
<span class="sd">        is supplied a new figure and axis is created.</span>

<span class="sd">        :param ax: Axes object on which the mesh is plotted</span>
<span class="sd">        :type ax: :class:`matplotlib.axes.Axes`</span>
<span class="sd">        :param bool pause: If set to true, the figure pauses the script until</span>
<span class="sd">            the window is closed. If set to false, the script continues</span>
<span class="sd">            immediately after the window is rendered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">:</span>
            <span class="c1"># plot the facets</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="c1"># plot the holes</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
            <span class="c1"># plot the controlPoitns</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">pause</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CustomSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.CustomSection">[docs]</a><span class="k">class</span> <span class="nc">CustomSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a cross section from a list of points, facets, holes and a</span>
<span class="sd">    user specified control point.</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">facets</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CustomSection class.&quot;&quot;&quot;</span>

        <span class="c1"># TODO: check for control_point</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="n">facets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="n">holes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="RectangularSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.RectangularSection">[docs]</a><span class="k">class</span> <span class="nc">RectangularSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a rectangular section with the bottom left corner at the</span>
<span class="sd">    origin *(0, 0)*, with depth *d* and width *b*.</span>

<span class="sd">    :param float d: Depth (y) of the rectangle</span>
<span class="sd">    :param float b: Width (x) of the rectangle</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a rectangular cross-section with a depth of</span>
<span class="sd">    100 and width of 50, and generates a mesh with a maximum triangular area of</span>
<span class="sd">    5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.RectangularSection(d=100, b=50)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the RectangularSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># construct the points and facets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CircularSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.CircularSection">[docs]</a><span class="k">class</span> <span class="nc">CircularSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a solid circle centered at the origin *(0, 0)* with diameter</span>
<span class="sd">    *d* and using *n* points to construct the circle.</span>

<span class="sd">    :param float d: Diameter of the circle</span>
<span class="sd">    :param int n: Number of points discretising the circle</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a circular cross-section with a diameter of</span>
<span class="sd">    50 with 32 points, and generates a mesh with a maximum triangular area of</span>
<span class="sd">    2.5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CircularSection(d=50, n=32)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CircularSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># loop through each point on the circle</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of the point</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current point to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the circle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChsSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.ChsSection">[docs]</a><span class="k">class</span> <span class="nc">ChsSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a circular hollow section centered at the origin *(0, 0)*,</span>
<span class="sd">    with diameter *d* and thickness *t*, using *n* points to construct the</span>
<span class="sd">    inner and outer circles.</span>

<span class="sd">    :param float d: Outer diameter of the CHS</span>
<span class="sd">    :param float t: Thickness of the CHS</span>
<span class="sd">    :param int n: Number of points discretising the inner and outer circles</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a CHS discretised with 64 points, with a</span>
<span class="sd">    diameter of 48 and thickness of 3.2, and generates a mesh with a maximum</span>
<span class="sd">    triangular area of 1.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.ChsSection(d=48, t=3.2, n=64)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[1.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ChsSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># specify a hole in the centre of the CHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># loop through each point of the CHS</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of outer and inner points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the circle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="RhsSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.RhsSection">[docs]</a><span class="k">class</span> <span class="nc">RhsSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a rectangular hollow section centered at *(b/2, d/2)*, with</span>
<span class="sd">    depth *d*, width *b*, thickness *t* and outer radius *r_out*, using *n_r*</span>
<span class="sd">    points to construct the inner and outer radii.</span>

<span class="sd">    :param float d: Depth of the RHS</span>
<span class="sd">    :param float b: Width of the RHS</span>
<span class="sd">    :param float t: Thickness of the RHS</span>
<span class="sd">    :param float r_out: Outer radius of the RHS</span>
<span class="sd">    :param int n_r: Number of points discretising the inner and outer radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an RHS with a depth of 100, a width of 50, a</span>
<span class="sd">    thickness of 6 and an outer radius of 9, using 8 points to discretise the</span>
<span class="sd">    inner and outer radii. A mesh is generated with a maximum triangular area</span>
<span class="sd">    of 2.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.RhsSection(d=100, b=50, t=6, r_out=9, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the RhsSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># specify a hole in the centre of the RHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="n">r_in</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span>  <span class="c1"># calculate internal radius</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="ISection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.ISection">[docs]</a><span class="k">class</span> <span class="nc">ISection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs an I-section centered at *(b/2, d/2)*, with depth *d*, width</span>
<span class="sd">    *b*, flange thickness *t_f*, web thickness *t_w*, and root radius *r*,</span>
<span class="sd">    using *n_r* points to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the I-section</span>
<span class="sd">    :param float b: Width of the I-section</span>
<span class="sd">    :param float t_f: Flange thickness of the I-section</span>
<span class="sd">    :param float t_w: Web thickness of the I-section</span>
<span class="sd">    :param float r: Root radius of the I-section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an I-section with a depth of 203, a width of</span>
<span class="sd">    133, a flange thickness of 7.8, a web thickness of 5.8 and a root radius of</span>
<span class="sd">    8.9, using 16 points to discretise the root radius. A mesh is generated</span>
<span class="sd">    with a maximum triangular area of 3.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[3.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ISection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next four points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the last point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="PfcSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.PfcSection">[docs]</a><span class="k">class</span> <span class="nc">PfcSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a PFC section with the bottom left corner at the origin</span>
<span class="sd">    *(0, 0)*, with depth *d*, width *b*, flange thickness *t_f*, web  thickness</span>
<span class="sd">    *t_w* and root radius *r*, using *n_r* points to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the PFC section</span>
<span class="sd">    :param float b: Width of the PFC section</span>
<span class="sd">    :param float t_f: Flange thickness of the PFC section</span>
<span class="sd">    :param float t_w: Web thickness of the PFC section</span>
<span class="sd">    :param float r: Root radius of the PFC section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a PFC section with a depth of 250, a width of</span>
<span class="sd">    90, a flange thickness of 15, a web thickness of 8 and a root radius of</span>
<span class="sd">    12, using 8 points to discretise the root radius. A mesh is generated</span>
<span class="sd">    with a maximum triangular area of 5.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.PfcSection(d=250, b=90, t_f=15, t_w=8, r=12, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the PfcSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">t_w</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">t_w</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add last three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="TeeSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.TeeSection">[docs]</a><span class="k">class</span> <span class="nc">TeeSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Tee section with the top left corner at *(0, d)*, with</span>
<span class="sd">    depth *d*, width *b*, flange thickness *t_f*, web thickness *t_w* and root</span>
<span class="sd">    radius *r*, using *n_r* points to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the Tee section</span>
<span class="sd">    :param float b: Width of the Tee section</span>
<span class="sd">    :param float t_f: Flange thickness of the Tee section</span>
<span class="sd">    :param float t_w: Web thickness of the Tee section</span>
<span class="sd">    :param float r: Root radius of the Tee section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Tee section with a depth of 200, a width of</span>
<span class="sd">    100, a flange thickness of 12, a web thickness of 6 and a root radius of</span>
<span class="sd">    8, using 8 points to discretise the root radius. A mesh is generated</span>
<span class="sd">    with a maximum triangular area of 3.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.TeeSection(d=200, b=100, t_f=12, t_w=6, r=8, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[3.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the TeeSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add next four points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="AngleSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.AngleSection">[docs]</a><span class="k">class</span> <span class="nc">AngleSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs an angle section with the bottom left corner at the origin</span>
<span class="sd">    *(0, 0)*, with depth *d*, width *b*, thickness *t*, root radius *r_r* and</span>
<span class="sd">    toe radius *r_t*, using *n_r* points to construct the radii.</span>

<span class="sd">    :param float d: Depth of the angle section</span>
<span class="sd">    :param float b: Width of the angle section</span>
<span class="sd">    :param float t: Thickness of the angle section</span>
<span class="sd">    :param float r_r: Root radius of the angle section</span>
<span class="sd">    :param float r_t: Toe radius of the angle section</span>
<span class="sd">    :param int n_r: Number of points discretising the radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an angle section with a depth of 150, a width</span>
<span class="sd">    of 100, a thickness of 8, a root radius of 12 and a toe radius of 5, using</span>
<span class="sd">    16 points to discretise the radii. A mesh is generated with a maximum</span>
<span class="sd">    triangular area of 2.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.AngleSection(d=150, b=100, t=8, r_r=12, r_t=5, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_r</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the AngleSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the bottom toe radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_t</span> <span class="o">+</span> <span class="n">r_t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_t</span> <span class="o">+</span> <span class="n">r_t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the root radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top toe radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_t</span> <span class="o">+</span> <span class="n">r_t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_t</span> <span class="o">+</span> <span class="n">r_t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CeeSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.CeeSection">[docs]</a><span class="k">class</span> <span class="nc">CeeSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Cee section with the bottom left corner at the origin</span>
<span class="sd">    *(0, 0)*, with depth *d*, width *b*, lip *l*, thickness *t* and outer</span>
<span class="sd">    radius *r_out*, using *n_r* points to construct the radius.</span>

<span class="sd">    :param float d: Depth of the Cee section</span>
<span class="sd">    :param float b: Width of the Cee section</span>
<span class="sd">    :param float l: Lip of the Cee section</span>
<span class="sd">    :param float t: Thickness of the Cee section</span>
<span class="sd">    :param float r_out: Outer radius of the Cee section</span>
<span class="sd">    :param int n_r: Number of points discretising the outer radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Cee section with a depth of 125, a width</span>
<span class="sd">    of 50, a lip of 30, a thickness of 1.5 and an outer radius of 6, using 8</span>
<span class="sd">    points to discretise the radius. A mesh is generated with a maximum</span>
<span class="sd">    triangular area of 0.25::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CeeSection(d=125, b=50, l=30, t=1.5, r_out=6, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.25])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CeeSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="n">r_in</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span>  <span class="c1"># calculate internal radius</span>

        <span class="c1"># construct the outer bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># construct the outer bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># add next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the inner top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the inner top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># add next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the outer top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># construct the outer top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="ZedSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.ZedSection">[docs]</a><span class="k">class</span> <span class="nc">ZedSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Zed section with the bottom left corner at the origin</span>
<span class="sd">    *(0, 0)*, with depth *d*, left flange width *b_l*, right flange width</span>
<span class="sd">    *b_r*, lip *l*, thickness *t* and outer radius *r_out*, using *n_r* points</span>
<span class="sd">    to construct the radius.</span>

<span class="sd">    :param float d: Depth of the Zed section</span>
<span class="sd">    :param float b_l: Left flange width of the Zed section</span>
<span class="sd">    :param float b_r: Right flange width of the Zed section</span>
<span class="sd">    :param float l: Lip of the Zed section</span>
<span class="sd">    :param float t: Thickness of the Zed section</span>
<span class="sd">    :param float r_out: Outer radius of the Zed section</span>
<span class="sd">    :param int n_r: Number of points discretising the outer radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Zed section with a depth of 100, a left</span>
<span class="sd">    flange width of 40, a right flange width of 50, a lip of 20, a thickness of</span>
<span class="sd">    1.2 and an outer radius of 5, using 8 points to discretise the radius.</span>
<span class="sd">    A mesh is generated with a maximum triangular area of 0.15::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.ZedSection(d=100, b_l=40, b_r=50, l=20, t=1.2, r_out=5, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.15])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ZedSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="n">r_in</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span>  <span class="c1"># calculate internal radius</span>

        <span class="c1"># construct the outer bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># construct the outer bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">b_r</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># add next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b_r</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b_r</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">b_r</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the outer top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># construct the outer top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># construct the inner top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CruciformSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.CruciformSection">[docs]</a><span class="k">class</span> <span class="nc">CruciformSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a cruciform section centered at the origin *(0, 0)*, with</span>
<span class="sd">    depth *d*, width *b*, thickness *t* and root radius *r*, using *n_r* points</span>
<span class="sd">    to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the cruciform section</span>
<span class="sd">    :param float b: Width of the cruciform section</span>
<span class="sd">    :param float t: Thickness of the cruciform section</span>
<span class="sd">    :param float r: Root radius of the cruciform section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a cruciform section with a depth of 250, a</span>
<span class="sd">    width of 175, a thickness of 12 and a root radius of 16, using 16 points to</span>
<span class="sd">    discretise the radius. A mesh is generated with a maximum triangular area</span>
<span class="sd">    of 5.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CruciformSection(d=250, b=175, t=12, r=16, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CruciformSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="c1"># calculate the locations of the radius points</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="MergedSection"><a class="viewcode-back" href="../../../rst/sections.html#sectionproperties.pre.sections.MergedSection">[docs]</a><span class="k">class</span> <span class="nc">MergedSection</span><span class="p">(</span><span class="n">SectionInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges a number of section geometries into one geometry. Note that for</span>
<span class="sd">    the meshing algorithm to work, there needs to be connectivity between all</span>
<span class="sd">    regions of the provided geometries. Overlapping of geometries is permitted.</span>

<span class="sd">    :param sections: A list of geometries to merge into one geometry</span>
<span class="sd">    :type sections: list[:class:`sectionproperties.pre.sections.SectionInput`]</span>

<span class="sd">    The following example creates a combined cross-section with a 150x100x6 RHS</span>
<span class="sd">    placed on its side on top of a 200UB25.4. A mesh is generated with a</span>
<span class="sd">    maximum triangle size of 5.0 for the I-section and 2.5 for the RHS::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        isection = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=8)</span>
<span class="sd">        box = sections.RhsSection(d=100, b=150, t=6, r_out=15, n_r=8, shift=[-8.5, 203])</span>

<span class="sd">        geometry = sections.MergedSection([isection, box])</span>
<span class="sd">        geometry.plot_geometry()</span>

<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0, 2.5])</span>

<span class="sd">    :cvar points: List of points *[x, y]* defining the vertices of the</span>
<span class="sd">        cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *[p1, p2]* defining the edges of</span>
<span class="sd">        the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *[x, y]* defining the locations of holes within</span>
<span class="sd">        the cross-section. If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *[x, y]* that define different</span>
<span class="sd">        regions of the cross-section. A control point is an arbitrary point</span>
<span class="sd">        within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *[x, y]*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the MergedSection class.&quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">point_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># loop through all sections</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="c1"># add facets</span>
            <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">facets</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">facet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_count</span><span class="p">,</span>
                                    <span class="n">facet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_count</span><span class="p">])</span>

            <span class="c1"># add points and count points</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">point_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add holes</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># add control points</span>
            <span class="k">for</span> <span class="n">control_point</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">control_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="n">control_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>


<span class="c1"># def sectionParse(sectionTypes, sectionData, settings):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Generates the geometry for the structural cross-section to be analysed,</span>
<span class="c1">#     defined by a number of different sectionTypes, containing various</span>
<span class="c1">#     sectionData. Note that there must be connectivity between all sections</span>
<span class="c1">#     (i.e. there cannot be isolated sections) or the meshing and/or</span>
<span class="c1">#     cross-section analysis will not work.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     # initialise output variables</span>
<span class="c1">#     points = []</span>
<span class="c1">#     facets = []</span>
<span class="c1">#     holes = []</span>
<span class="c1">#     controlPoints = []</span>
<span class="c1">#</span>
<span class="c1">#     # initialise pointCount variable</span>
<span class="c1">#     pointCount = 0</span>
<span class="c1">#</span>
<span class="c1">#     # loop through each section</span>
<span class="c1">#     for (i, section) in enumerate(sectionTypes):</span>
<span class="c1">#         # generate new section depending on section type</span>
<span class="c1">#         if (section == &quot;custom&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 pointData = sectionData[i][&quot;points&quot;]</span>
<span class="c1">#                 facetData = sectionData[i][&quot;facets&quot;]</span>
<span class="c1">#                 holeData = sectionData[i][&quot;holes&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateCustom(pointData, facetData, holeData, x, y,</span>
<span class="c1">#                                         controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;rectangle&quot;):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 # load data from current sectionData</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateRectangle(d, b, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;circle&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 n = sectionData[i][&quot;n&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateCircle(d, n, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;chs&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 n = sectionData[i][&quot;n&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateCHS(d, t, n, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;rhs&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 r_out = sectionData[i][&quot;r_out&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateRHS(</span>
<span class="c1">#                 d, b, t, r_out, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;i-section&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 tf = sectionData[i][&quot;tf&quot;]</span>
<span class="c1">#                 tw = sectionData[i][&quot;tw&quot;]</span>
<span class="c1">#                 r = sectionData[i][&quot;r&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateISection(</span>
<span class="c1">#                 d, b, tf, tw, r, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;pfc&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 tf = sectionData[i][&quot;tf&quot;]</span>
<span class="c1">#                 tw = sectionData[i][&quot;tw&quot;]</span>
<span class="c1">#                 r = sectionData[i][&quot;r&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generatePFCSection(</span>
<span class="c1">#                 d, b, tf, tw, r, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;tee&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 tf = sectionData[i][&quot;tf&quot;]</span>
<span class="c1">#                 tw = sectionData[i][&quot;tw&quot;]</span>
<span class="c1">#                 r = sectionData[i][&quot;r&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateTeeSection(</span>
<span class="c1">#                 d, b, tf, tw, r, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;angle&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 r_root = sectionData[i][&quot;r_root&quot;]</span>
<span class="c1">#                 r_toe = sectionData[i][&quot;r_toe&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateAngleSection(</span>
<span class="c1">#                 d, b, t, r_root, r_toe, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;cee&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 lip = sectionData[i][&quot;l&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 r_out = sectionData[i][&quot;r_out&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateCeeSection(</span>
<span class="c1">#                 d, b, lip, t, r_out, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;zed&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b1 = sectionData[i][&quot;b1&quot;]</span>
<span class="c1">#                 b2 = sectionData[i][&quot;b2&quot;]</span>
<span class="c1">#                 lip = sectionData[i][&quot;l&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 r_out = sectionData[i][&quot;r_out&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateZedSection(</span>
<span class="c1">#                 d, b1, b2, lip, t, r_out, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         elif (section == &quot;cruciform&quot;):</span>
<span class="c1">#             # load data from current sectionData</span>
<span class="c1">#             try:</span>
<span class="c1">#                 d = sectionData[i][&quot;d&quot;]</span>
<span class="c1">#                 b = sectionData[i][&quot;b&quot;]</span>
<span class="c1">#                 t = sectionData[i][&quot;t&quot;]</span>
<span class="c1">#                 r = sectionData[i][&quot;r&quot;]</span>
<span class="c1">#                 n_r = sectionData[i][&quot;n_r&quot;]</span>
<span class="c1">#                 x = sectionData[i][&quot;x&quot;]</span>
<span class="c1">#                 y = sectionData[i][&quot;y&quot;]</span>
<span class="c1">#             except KeyError as err:</span>
<span class="c1">#                 handleKeyError(err, section)</span>
<span class="c1">#</span>
<span class="c1">#             # if there is a control-point, load it</span>
<span class="c1">#             try:</span>
<span class="c1">#                 controlPointData = sectionData[i][&quot;control-point&quot;]</span>
<span class="c1">#             # if there is no control-point, set it to None</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 controlPointData = None</span>
<span class="c1">#</span>
<span class="c1">#             # generate a new section</span>
<span class="c1">#             newSection = generateCruciform(</span>
<span class="c1">#                 d, b, t, r, n_r, x, y, controlPointData)</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             print(&quot;Error: section type &#39;{}&#39; is not defined.&quot;.format(section))</span>
<span class="c1">#             quit()</span>
<span class="c1">#</span>
<span class="c1">#         # get points, facets, holes and controlpoint from newSection</span>
<span class="c1">#         (newPoints, newFacets, newHoles,</span>
<span class="c1">#          newControlPoint) = newSection.returnSection()</span>
<span class="c1">#</span>
<span class="c1">#         # loop through the facets in the newSection and append to the list</span>
<span class="c1">#         for f in newFacets:</span>
<span class="c1">#             facets.append([f[0] + pointCount, f[1] + pointCount])</span>
<span class="c1">#</span>
<span class="c1">#         # loop through the points in the newSection and append to the list</span>
<span class="c1">#         for p in newPoints:</span>
<span class="c1">#             pointCount += 1</span>
<span class="c1">#             points.append([p[0], p[1]])</span>
<span class="c1">#</span>
<span class="c1">#         # loop through the holes in the newSection and append to the list</span>
<span class="c1">#         for h in newHoles:</span>
<span class="c1">#             holes.append([h[0], h[1]])</span>
<span class="c1">#</span>
<span class="c1">#         # append the controlPoint from the newSection</span>
<span class="c1">#         controlPoints.append([newControlPoint[0], newControlPoint[1]])</span>
<span class="c1">#</span>
<span class="c1">#     if (settings.outputLog):</span>
<span class="c1">#         print(&quot;-- Loaded {0} points, {1} facets and {2} holes &quot;.format(</span>
<span class="c1">#             len(points), len(facets), len(holes)) +</span>
<span class="c1">#             &quot;from {0} sections.&quot;.format(len(sectionTypes)))</span>
<span class="c1">#</span>
<span class="c1">#     return (points, facets, holes, controlPoints)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def handleKeyError(err, section):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Displays an error message if the correct keys are not provided for the</span>
<span class="c1">#     current section and quits the program.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     print(</span>
<span class="c1">#         &quot;Error: Required key {0} not found for section type &#39;{1}&#39;.&quot;.format(</span>
<span class="c1">#             err, section) +</span>
<span class="c1">#         &quot; Refer to the documentation for the required keys.&quot;)</span>
<span class="c1">#     quit()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Robbie van Leeuwen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>